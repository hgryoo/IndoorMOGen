//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.10.10 at 10:41:43 AM KST 
//


package net.opengis.citygml.v_2_0;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;
import net.opengis.citygml.appearance.v_2_0.AppearancePropertyType;
import net.opengis.citygml.bridge.v_2_0.BridgeConstructionElementType;
import net.opengis.citygml.bridge.v_2_0.BridgeFurnitureType;
import net.opengis.citygml.bridge.v_2_0.BridgeInstallationType;
import net.opengis.citygml.bridge.v_2_0.BridgeRoomType;
import net.opengis.citygml.bridge.v_2_0.IntBridgeInstallationType;
import net.opengis.citygml.building.v_2_0.BuildingFurnitureType;
import net.opengis.citygml.building.v_2_0.BuildingInstallationType;
import net.opengis.citygml.building.v_2_0.IntBuildingInstallationType;
import net.opengis.citygml.building.v_2_0.RoomType;
import net.opengis.citygml.cityfurniture.v_2_0.CityFurnitureType;
import net.opengis.citygml.cityobjectgroup.v_2_0.CityObjectGroupType;
import net.opengis.citygml.generics.v_2_0.AbstractGenericAttributeType;
import net.opengis.citygml.generics.v_2_0.DateAttributeType;
import net.opengis.citygml.generics.v_2_0.DoubleAttributeType;
import net.opengis.citygml.generics.v_2_0.GenericAttributeSetType;
import net.opengis.citygml.generics.v_2_0.GenericCityObjectType;
import net.opengis.citygml.generics.v_2_0.IntAttributeType;
import net.opengis.citygml.generics.v_2_0.MeasureAttributeType;
import net.opengis.citygml.generics.v_2_0.StringAttributeType;
import net.opengis.citygml.generics.v_2_0.UriAttributeType;
import net.opengis.citygml.landUse.v_2_0.LandUseType;
import net.opengis.citygml.relief.v_2_0.AbstractReliefComponentType;
import net.opengis.citygml.relief.v_2_0.ReliefFeatureType;
import net.opengis.citygml.transportation.v_2_0.AbstractTransportationObjectType;
import net.opengis.citygml.tunnel.v_2_0.HollowSpaceType;
import net.opengis.citygml.tunnel.v_2_0.IntTunnelInstallationType;
import net.opengis.citygml.tunnel.v_2_0.TunnelFurnitureType;
import net.opengis.citygml.tunnel.v_2_0.TunnelInstallationType;
import net.opengis.citygml.vegetation.v_2_0.AbstractVegetationObjectType;
import net.opengis.citygml.waterbody.v_2_0.AbstractWaterBoundarySurfaceType;
import net.opengis.citygml.waterbody.v_2_0.AbstractWaterObjectType;
import net.opengis.gml.v_3_1_1.AbstractFeatureType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * Type describing the abstract superclass of most CityGML features. Its purpose is to provide a creation and
 * 				a termination date as well as a reference to corresponding objects in other information systems. A generalization relation
 * 				may be used to relate features, which represent the same real-world object in different Levels-of-Detail, i.e. a feature
 * 				and its generalized counterpart(s). The direction of this relation is from the feature to the corresponding generalized
 * 				feature.
 * 
 * <p>Java class for AbstractCityObjectType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="AbstractCityObjectType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.opengis.net/gml}AbstractFeatureType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="creationDate" type="{http://www.w3.org/2001/XMLSchema}date" minOccurs="0"/&gt;
 *         &lt;element name="terminationDate" type="{http://www.w3.org/2001/XMLSchema}date" minOccurs="0"/&gt;
 *         &lt;element name="externalReference" type="{http://www.opengis.net/citygml/2.0}ExternalReferenceType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="generalizesTo" type="{http://www.opengis.net/citygml/2.0}GeneralizationRelationType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="relativeToTerrain" type="{http://www.opengis.net/citygml/2.0}RelativeToTerrainType" minOccurs="0"/&gt;
 *         &lt;element name="relativeToWater" type="{http://www.opengis.net/citygml/2.0}RelativeToWaterType" minOccurs="0"/&gt;
 *         &lt;element ref="{http://www.opengis.net/citygml/2.0}_GenericApplicationPropertyOfCityObject" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "AbstractCityObjectType", propOrder = {
    "creationDate",
    "terminationDate",
    "externalReference",
    "generalizesTo",
    "relativeToTerrain",
    "relativeToWater",
    "genericApplicationPropertyOfCityObject"
})
@XmlSeeAlso({
    BridgeInstallationType.class,
    IntBridgeInstallationType.class,
    BridgeConstructionElementType.class,
    net.opengis.citygml.bridge.v_2_0.AbstractBoundarySurfaceType.class,
    net.opengis.citygml.bridge.v_2_0.AbstractOpeningType.class,
    BridgeRoomType.class,
    BridgeFurnitureType.class,
    BuildingInstallationType.class,
    IntBuildingInstallationType.class,
    net.opengis.citygml.building.v_2_0.AbstractBoundarySurfaceType.class,
    net.opengis.citygml.building.v_2_0.AbstractOpeningType.class,
    RoomType.class,
    BuildingFurnitureType.class,
    CityFurnitureType.class,
    CityObjectGroupType.class,
    GenericCityObjectType.class,
    LandUseType.class,
    ReliefFeatureType.class,
    AbstractReliefComponentType.class,
    AbstractTransportationObjectType.class,
    AbstractSiteType.class,
    TunnelInstallationType.class,
    IntTunnelInstallationType.class,
    net.opengis.citygml.tunnel.v_2_0.AbstractBoundarySurfaceType.class,
    HollowSpaceType.class,
    TunnelFurnitureType.class,
    net.opengis.citygml.tunnel.v_2_0.AbstractOpeningType.class,
    AbstractVegetationObjectType.class,
    AbstractWaterObjectType.class,
    AbstractWaterBoundarySurfaceType.class
})
public abstract class AbstractCityObjectType
    extends AbstractFeatureType
    implements Cloneable, CopyTo, Equals, HashCode, ToString
{

    @XmlSchemaType(name = "date")
    protected XMLGregorianCalendar creationDate;
    @XmlSchemaType(name = "date")
    protected XMLGregorianCalendar terminationDate;
    protected List<ExternalReferenceType> externalReference;
    protected List<GeneralizationRelationType> generalizesTo;
    @XmlSchemaType(name = "string")
    protected RelativeToTerrainType relativeToTerrain;
    @XmlSchemaType(name = "string")
    protected RelativeToWaterType relativeToWater;
    @XmlElementRef(name = "_GenericApplicationPropertyOfCityObject", namespace = "http://www.opengis.net/citygml/2.0", type = JAXBElement.class, required = false)
    protected List<JAXBElement<?>> genericApplicationPropertyOfCityObject;

    /**
     * Gets the value of the creationDate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getCreationDate() {
        return creationDate;
    }

    /**
     * Sets the value of the creationDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setCreationDate(XMLGregorianCalendar value) {
        this.creationDate = value;
    }

    public boolean isSetCreationDate() {
        return (this.creationDate!= null);
    }

    /**
     * Gets the value of the terminationDate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getTerminationDate() {
        return terminationDate;
    }

    /**
     * Sets the value of the terminationDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setTerminationDate(XMLGregorianCalendar value) {
        this.terminationDate = value;
    }

    public boolean isSetTerminationDate() {
        return (this.terminationDate!= null);
    }

    /**
     * Gets the value of the externalReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the externalReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getExternalReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ExternalReferenceType }
     * 
     * 
     */
    public List<ExternalReferenceType> getExternalReference() {
        if (externalReference == null) {
            externalReference = new ArrayList<ExternalReferenceType>();
        }
        return this.externalReference;
    }

    public boolean isSetExternalReference() {
        return ((this.externalReference!= null)&&(!this.externalReference.isEmpty()));
    }

    public void unsetExternalReference() {
        this.externalReference = null;
    }

    /**
     * Gets the value of the generalizesTo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the generalizesTo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeneralizesTo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GeneralizationRelationType }
     * 
     * 
     */
    public List<GeneralizationRelationType> getGeneralizesTo() {
        if (generalizesTo == null) {
            generalizesTo = new ArrayList<GeneralizationRelationType>();
        }
        return this.generalizesTo;
    }

    public boolean isSetGeneralizesTo() {
        return ((this.generalizesTo!= null)&&(!this.generalizesTo.isEmpty()));
    }

    public void unsetGeneralizesTo() {
        this.generalizesTo = null;
    }

    /**
     * Gets the value of the relativeToTerrain property.
     * 
     * @return
     *     possible object is
     *     {@link RelativeToTerrainType }
     *     
     */
    public RelativeToTerrainType getRelativeToTerrain() {
        return relativeToTerrain;
    }

    /**
     * Sets the value of the relativeToTerrain property.
     * 
     * @param value
     *     allowed object is
     *     {@link RelativeToTerrainType }
     *     
     */
    public void setRelativeToTerrain(RelativeToTerrainType value) {
        this.relativeToTerrain = value;
    }

    public boolean isSetRelativeToTerrain() {
        return (this.relativeToTerrain!= null);
    }

    /**
     * Gets the value of the relativeToWater property.
     * 
     * @return
     *     possible object is
     *     {@link RelativeToWaterType }
     *     
     */
    public RelativeToWaterType getRelativeToWater() {
        return relativeToWater;
    }

    /**
     * Sets the value of the relativeToWater property.
     * 
     * @param value
     *     allowed object is
     *     {@link RelativeToWaterType }
     *     
     */
    public void setRelativeToWater(RelativeToWaterType value) {
        this.relativeToWater = value;
    }

    public boolean isSetRelativeToWater() {
        return (this.relativeToWater!= null);
    }

    /**
     * Gets the value of the genericApplicationPropertyOfCityObject property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the genericApplicationPropertyOfCityObject property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGenericApplicationPropertyOfCityObject().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link AppearancePropertyType }{@code >}
     * {@link JAXBElement }{@code <}{@link AbstractGenericAttributeType }{@code >}
     * {@link JAXBElement }{@code <}{@link StringAttributeType }{@code >}
     * {@link JAXBElement }{@code <}{@link DoubleAttributeType }{@code >}
     * {@link JAXBElement }{@code <}{@link GenericAttributeSetType }{@code >}
     * {@link JAXBElement }{@code <}{@link MeasureAttributeType }{@code >}
     * {@link JAXBElement }{@code <}{@link DateAttributeType }{@code >}
     * {@link JAXBElement }{@code <}{@link Object }{@code >}
     * {@link JAXBElement }{@code <}{@link UriAttributeType }{@code >}
     * {@link JAXBElement }{@code <}{@link IntAttributeType }{@code >}
     * 
     * 
     */
    public List<JAXBElement<?>> getGenericApplicationPropertyOfCityObject() {
        if (genericApplicationPropertyOfCityObject == null) {
            genericApplicationPropertyOfCityObject = new ArrayList<JAXBElement<?>>();
        }
        return this.genericApplicationPropertyOfCityObject;
    }

    public boolean isSetGenericApplicationPropertyOfCityObject() {
        return ((this.genericApplicationPropertyOfCityObject!= null)&&(!this.genericApplicationPropertyOfCityObject.isEmpty()));
    }

    public void unsetGenericApplicationPropertyOfCityObject() {
        this.genericApplicationPropertyOfCityObject = null;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            XMLGregorianCalendar theCreationDate;
            theCreationDate = this.getCreationDate();
            strategy.appendField(locator, this, "creationDate", buffer, theCreationDate);
        }
        {
            XMLGregorianCalendar theTerminationDate;
            theTerminationDate = this.getTerminationDate();
            strategy.appendField(locator, this, "terminationDate", buffer, theTerminationDate);
        }
        {
            List<ExternalReferenceType> theExternalReference;
            theExternalReference = (this.isSetExternalReference()?this.getExternalReference():null);
            strategy.appendField(locator, this, "externalReference", buffer, theExternalReference);
        }
        {
            List<GeneralizationRelationType> theGeneralizesTo;
            theGeneralizesTo = (this.isSetGeneralizesTo()?this.getGeneralizesTo():null);
            strategy.appendField(locator, this, "generalizesTo", buffer, theGeneralizesTo);
        }
        {
            RelativeToTerrainType theRelativeToTerrain;
            theRelativeToTerrain = this.getRelativeToTerrain();
            strategy.appendField(locator, this, "relativeToTerrain", buffer, theRelativeToTerrain);
        }
        {
            RelativeToWaterType theRelativeToWater;
            theRelativeToWater = this.getRelativeToWater();
            strategy.appendField(locator, this, "relativeToWater", buffer, theRelativeToWater);
        }
        {
            List<JAXBElement<?>> theGenericApplicationPropertyOfCityObject;
            theGenericApplicationPropertyOfCityObject = (this.isSetGenericApplicationPropertyOfCityObject()?this.getGenericApplicationPropertyOfCityObject():null);
            strategy.appendField(locator, this, "genericApplicationPropertyOfCityObject", buffer, theGenericApplicationPropertyOfCityObject);
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof AbstractCityObjectType)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final AbstractCityObjectType that = ((AbstractCityObjectType) object);
        {
            XMLGregorianCalendar lhsCreationDate;
            lhsCreationDate = this.getCreationDate();
            XMLGregorianCalendar rhsCreationDate;
            rhsCreationDate = that.getCreationDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "creationDate", lhsCreationDate), LocatorUtils.property(thatLocator, "creationDate", rhsCreationDate), lhsCreationDate, rhsCreationDate)) {
                return false;
            }
        }
        {
            XMLGregorianCalendar lhsTerminationDate;
            lhsTerminationDate = this.getTerminationDate();
            XMLGregorianCalendar rhsTerminationDate;
            rhsTerminationDate = that.getTerminationDate();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "terminationDate", lhsTerminationDate), LocatorUtils.property(thatLocator, "terminationDate", rhsTerminationDate), lhsTerminationDate, rhsTerminationDate)) {
                return false;
            }
        }
        {
            List<ExternalReferenceType> lhsExternalReference;
            lhsExternalReference = (this.isSetExternalReference()?this.getExternalReference():null);
            List<ExternalReferenceType> rhsExternalReference;
            rhsExternalReference = (that.isSetExternalReference()?that.getExternalReference():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "externalReference", lhsExternalReference), LocatorUtils.property(thatLocator, "externalReference", rhsExternalReference), lhsExternalReference, rhsExternalReference)) {
                return false;
            }
        }
        {
            List<GeneralizationRelationType> lhsGeneralizesTo;
            lhsGeneralizesTo = (this.isSetGeneralizesTo()?this.getGeneralizesTo():null);
            List<GeneralizationRelationType> rhsGeneralizesTo;
            rhsGeneralizesTo = (that.isSetGeneralizesTo()?that.getGeneralizesTo():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "generalizesTo", lhsGeneralizesTo), LocatorUtils.property(thatLocator, "generalizesTo", rhsGeneralizesTo), lhsGeneralizesTo, rhsGeneralizesTo)) {
                return false;
            }
        }
        {
            RelativeToTerrainType lhsRelativeToTerrain;
            lhsRelativeToTerrain = this.getRelativeToTerrain();
            RelativeToTerrainType rhsRelativeToTerrain;
            rhsRelativeToTerrain = that.getRelativeToTerrain();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "relativeToTerrain", lhsRelativeToTerrain), LocatorUtils.property(thatLocator, "relativeToTerrain", rhsRelativeToTerrain), lhsRelativeToTerrain, rhsRelativeToTerrain)) {
                return false;
            }
        }
        {
            RelativeToWaterType lhsRelativeToWater;
            lhsRelativeToWater = this.getRelativeToWater();
            RelativeToWaterType rhsRelativeToWater;
            rhsRelativeToWater = that.getRelativeToWater();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "relativeToWater", lhsRelativeToWater), LocatorUtils.property(thatLocator, "relativeToWater", rhsRelativeToWater), lhsRelativeToWater, rhsRelativeToWater)) {
                return false;
            }
        }
        {
            List<JAXBElement<?>> lhsGenericApplicationPropertyOfCityObject;
            lhsGenericApplicationPropertyOfCityObject = (this.isSetGenericApplicationPropertyOfCityObject()?this.getGenericApplicationPropertyOfCityObject():null);
            List<JAXBElement<?>> rhsGenericApplicationPropertyOfCityObject;
            rhsGenericApplicationPropertyOfCityObject = (that.isSetGenericApplicationPropertyOfCityObject()?that.getGenericApplicationPropertyOfCityObject():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "genericApplicationPropertyOfCityObject", lhsGenericApplicationPropertyOfCityObject), LocatorUtils.property(thatLocator, "genericApplicationPropertyOfCityObject", rhsGenericApplicationPropertyOfCityObject), lhsGenericApplicationPropertyOfCityObject, rhsGenericApplicationPropertyOfCityObject)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            XMLGregorianCalendar theCreationDate;
            theCreationDate = this.getCreationDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "creationDate", theCreationDate), currentHashCode, theCreationDate);
        }
        {
            XMLGregorianCalendar theTerminationDate;
            theTerminationDate = this.getTerminationDate();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "terminationDate", theTerminationDate), currentHashCode, theTerminationDate);
        }
        {
            List<ExternalReferenceType> theExternalReference;
            theExternalReference = (this.isSetExternalReference()?this.getExternalReference():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "externalReference", theExternalReference), currentHashCode, theExternalReference);
        }
        {
            List<GeneralizationRelationType> theGeneralizesTo;
            theGeneralizesTo = (this.isSetGeneralizesTo()?this.getGeneralizesTo():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "generalizesTo", theGeneralizesTo), currentHashCode, theGeneralizesTo);
        }
        {
            RelativeToTerrainType theRelativeToTerrain;
            theRelativeToTerrain = this.getRelativeToTerrain();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "relativeToTerrain", theRelativeToTerrain), currentHashCode, theRelativeToTerrain);
        }
        {
            RelativeToWaterType theRelativeToWater;
            theRelativeToWater = this.getRelativeToWater();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "relativeToWater", theRelativeToWater), currentHashCode, theRelativeToWater);
        }
        {
            List<JAXBElement<?>> theGenericApplicationPropertyOfCityObject;
            theGenericApplicationPropertyOfCityObject = (this.isSetGenericApplicationPropertyOfCityObject()?this.getGenericApplicationPropertyOfCityObject():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "genericApplicationPropertyOfCityObject", theGenericApplicationPropertyOfCityObject), currentHashCode, theGenericApplicationPropertyOfCityObject);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        if (null == target) {
            throw new IllegalArgumentException("Target argument must not be null for abstract copyable classes.");
        }
        super.copyTo(locator, target, strategy);
        if (target instanceof AbstractCityObjectType) {
            final AbstractCityObjectType copy = ((AbstractCityObjectType) target);
            if (this.isSetCreationDate()) {
                XMLGregorianCalendar sourceCreationDate;
                sourceCreationDate = this.getCreationDate();
                XMLGregorianCalendar copyCreationDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "creationDate", sourceCreationDate), sourceCreationDate));
                copy.setCreationDate(copyCreationDate);
            } else {
                copy.creationDate = null;
            }
            if (this.isSetTerminationDate()) {
                XMLGregorianCalendar sourceTerminationDate;
                sourceTerminationDate = this.getTerminationDate();
                XMLGregorianCalendar copyTerminationDate = ((XMLGregorianCalendar) strategy.copy(LocatorUtils.property(locator, "terminationDate", sourceTerminationDate), sourceTerminationDate));
                copy.setTerminationDate(copyTerminationDate);
            } else {
                copy.terminationDate = null;
            }
            if (this.isSetExternalReference()) {
                List<ExternalReferenceType> sourceExternalReference;
                sourceExternalReference = (this.isSetExternalReference()?this.getExternalReference():null);
                @SuppressWarnings("unchecked")
                List<ExternalReferenceType> copyExternalReference = ((List<ExternalReferenceType> ) strategy.copy(LocatorUtils.property(locator, "externalReference", sourceExternalReference), sourceExternalReference));
                copy.unsetExternalReference();
                if (copyExternalReference!= null) {
                    List<ExternalReferenceType> uniqueExternalReferencel = copy.getExternalReference();
                    uniqueExternalReferencel.addAll(copyExternalReference);
                }
            } else {
                copy.unsetExternalReference();
            }
            if (this.isSetGeneralizesTo()) {
                List<GeneralizationRelationType> sourceGeneralizesTo;
                sourceGeneralizesTo = (this.isSetGeneralizesTo()?this.getGeneralizesTo():null);
                @SuppressWarnings("unchecked")
                List<GeneralizationRelationType> copyGeneralizesTo = ((List<GeneralizationRelationType> ) strategy.copy(LocatorUtils.property(locator, "generalizesTo", sourceGeneralizesTo), sourceGeneralizesTo));
                copy.unsetGeneralizesTo();
                if (copyGeneralizesTo!= null) {
                    List<GeneralizationRelationType> uniqueGeneralizesTol = copy.getGeneralizesTo();
                    uniqueGeneralizesTol.addAll(copyGeneralizesTo);
                }
            } else {
                copy.unsetGeneralizesTo();
            }
            if (this.isSetRelativeToTerrain()) {
                RelativeToTerrainType sourceRelativeToTerrain;
                sourceRelativeToTerrain = this.getRelativeToTerrain();
                RelativeToTerrainType copyRelativeToTerrain = ((RelativeToTerrainType) strategy.copy(LocatorUtils.property(locator, "relativeToTerrain", sourceRelativeToTerrain), sourceRelativeToTerrain));
                copy.setRelativeToTerrain(copyRelativeToTerrain);
            } else {
                copy.relativeToTerrain = null;
            }
            if (this.isSetRelativeToWater()) {
                RelativeToWaterType sourceRelativeToWater;
                sourceRelativeToWater = this.getRelativeToWater();
                RelativeToWaterType copyRelativeToWater = ((RelativeToWaterType) strategy.copy(LocatorUtils.property(locator, "relativeToWater", sourceRelativeToWater), sourceRelativeToWater));
                copy.setRelativeToWater(copyRelativeToWater);
            } else {
                copy.relativeToWater = null;
            }
            if (this.isSetGenericApplicationPropertyOfCityObject()) {
                List<JAXBElement<?>> sourceGenericApplicationPropertyOfCityObject;
                sourceGenericApplicationPropertyOfCityObject = (this.isSetGenericApplicationPropertyOfCityObject()?this.getGenericApplicationPropertyOfCityObject():null);
                @SuppressWarnings("unchecked")
                List<JAXBElement<?>> copyGenericApplicationPropertyOfCityObject = ((List<JAXBElement<?>> ) strategy.copy(LocatorUtils.property(locator, "genericApplicationPropertyOfCityObject", sourceGenericApplicationPropertyOfCityObject), sourceGenericApplicationPropertyOfCityObject));
                copy.unsetGenericApplicationPropertyOfCityObject();
                if (copyGenericApplicationPropertyOfCityObject!= null) {
                    List<JAXBElement<?>> uniqueGenericApplicationPropertyOfCityObjectl = copy.getGenericApplicationPropertyOfCityObject();
                    uniqueGenericApplicationPropertyOfCityObjectl.addAll(copyGenericApplicationPropertyOfCityObject);
                }
            } else {
                copy.unsetGenericApplicationPropertyOfCityObject();
            }
        }
        return target;
    }

}
