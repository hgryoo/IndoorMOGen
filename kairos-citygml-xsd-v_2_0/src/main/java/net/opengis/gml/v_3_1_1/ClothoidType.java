//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.10.10 at 10:41:43 AM KST 
//


package net.opengis.gml.v_3_1_1;

import java.math.BigDecimal;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * A clothoid, or Cornu's spiral, is plane
 *    curve whose curvature is a fixed function of its length.
 *    In suitably chosen co-ordinates it is given by Fresnel's
 *    integrals.
 * 
 *     x(t) = 0-integral-t cos(AT*T/2)dT    
 *     
 *     y(t) = 0-integral-t sin(AT*T/2)dT
 *    
 *    This geometry is mainly used as a transition curve between
 *    curves of type straight line to circular arc or circular arc
 *    to circular arc. With this curve type it is possible to 
 *    achieve a C2-continous transition between the above mentioned
 *    curve types. One formula for the Clothoid is A*A = R*t where
 *    A is constant, R is the varying radius of curvature along the
 *    the curve and t is the length along and given in the Fresnel 
 *    integrals.
 * 
 * <p>Java class for ClothoidType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ClothoidType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.opengis.net/gml}AbstractCurveSegmentType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="refLocation"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element ref="{http://www.opengis.net/gml}AffinePlacement"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="scaleFactor" type="{http://www.w3.org/2001/XMLSchema}decimal"/&gt;
 *         &lt;element name="startParameter" type="{http://www.w3.org/2001/XMLSchema}double"/&gt;
 *         &lt;element name="endParameter" type="{http://www.w3.org/2001/XMLSchema}double"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ClothoidType", propOrder = {
    "refLocation",
    "scaleFactor",
    "startParameter",
    "endParameter"
})
public class ClothoidType
    extends AbstractCurveSegmentType
    implements Cloneable, CopyTo, Equals, HashCode, ToString
{

    @XmlElement(required = true)
    protected ClothoidType.RefLocation refLocation;
    @XmlElement(required = true)
    protected BigDecimal scaleFactor;
    protected double startParameter;
    protected double endParameter;

    /**
     * Gets the value of the refLocation property.
     * 
     * @return
     *     possible object is
     *     {@link ClothoidType.RefLocation }
     *     
     */
    public ClothoidType.RefLocation getRefLocation() {
        return refLocation;
    }

    /**
     * Sets the value of the refLocation property.
     * 
     * @param value
     *     allowed object is
     *     {@link ClothoidType.RefLocation }
     *     
     */
    public void setRefLocation(ClothoidType.RefLocation value) {
        this.refLocation = value;
    }

    public boolean isSetRefLocation() {
        return (this.refLocation!= null);
    }

    /**
     * Gets the value of the scaleFactor property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */
    public BigDecimal getScaleFactor() {
        return scaleFactor;
    }

    /**
     * Sets the value of the scaleFactor property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */
    public void setScaleFactor(BigDecimal value) {
        this.scaleFactor = value;
    }

    public boolean isSetScaleFactor() {
        return (this.scaleFactor!= null);
    }

    /**
     * Gets the value of the startParameter property.
     * 
     */
    public double getStartParameter() {
        return startParameter;
    }

    /**
     * Sets the value of the startParameter property.
     * 
     */
    public void setStartParameter(double value) {
        this.startParameter = value;
    }

    public boolean isSetStartParameter() {
        return true;
    }

    /**
     * Gets the value of the endParameter property.
     * 
     */
    public double getEndParameter() {
        return endParameter;
    }

    /**
     * Sets the value of the endParameter property.
     * 
     */
    public void setEndParameter(double value) {
        this.endParameter = value;
    }

    public boolean isSetEndParameter() {
        return true;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            ClothoidType.RefLocation theRefLocation;
            theRefLocation = this.getRefLocation();
            strategy.appendField(locator, this, "refLocation", buffer, theRefLocation);
        }
        {
            BigDecimal theScaleFactor;
            theScaleFactor = this.getScaleFactor();
            strategy.appendField(locator, this, "scaleFactor", buffer, theScaleFactor);
        }
        {
            double theStartParameter;
            theStartParameter = this.getStartParameter();
            strategy.appendField(locator, this, "startParameter", buffer, theStartParameter);
        }
        {
            double theEndParameter;
            theEndParameter = this.getEndParameter();
            strategy.appendField(locator, this, "endParameter", buffer, theEndParameter);
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof ClothoidType)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final ClothoidType that = ((ClothoidType) object);
        {
            ClothoidType.RefLocation lhsRefLocation;
            lhsRefLocation = this.getRefLocation();
            ClothoidType.RefLocation rhsRefLocation;
            rhsRefLocation = that.getRefLocation();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "refLocation", lhsRefLocation), LocatorUtils.property(thatLocator, "refLocation", rhsRefLocation), lhsRefLocation, rhsRefLocation)) {
                return false;
            }
        }
        {
            BigDecimal lhsScaleFactor;
            lhsScaleFactor = this.getScaleFactor();
            BigDecimal rhsScaleFactor;
            rhsScaleFactor = that.getScaleFactor();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "scaleFactor", lhsScaleFactor), LocatorUtils.property(thatLocator, "scaleFactor", rhsScaleFactor), lhsScaleFactor, rhsScaleFactor)) {
                return false;
            }
        }
        {
            double lhsStartParameter;
            lhsStartParameter = this.getStartParameter();
            double rhsStartParameter;
            rhsStartParameter = that.getStartParameter();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "startParameter", lhsStartParameter), LocatorUtils.property(thatLocator, "startParameter", rhsStartParameter), lhsStartParameter, rhsStartParameter)) {
                return false;
            }
        }
        {
            double lhsEndParameter;
            lhsEndParameter = this.getEndParameter();
            double rhsEndParameter;
            rhsEndParameter = that.getEndParameter();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "endParameter", lhsEndParameter), LocatorUtils.property(thatLocator, "endParameter", rhsEndParameter), lhsEndParameter, rhsEndParameter)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            ClothoidType.RefLocation theRefLocation;
            theRefLocation = this.getRefLocation();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "refLocation", theRefLocation), currentHashCode, theRefLocation);
        }
        {
            BigDecimal theScaleFactor;
            theScaleFactor = this.getScaleFactor();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "scaleFactor", theScaleFactor), currentHashCode, theScaleFactor);
        }
        {
            double theStartParameter;
            theStartParameter = this.getStartParameter();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "startParameter", theStartParameter), currentHashCode, theStartParameter);
        }
        {
            double theEndParameter;
            theEndParameter = this.getEndParameter();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "endParameter", theEndParameter), currentHashCode, theEndParameter);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        super.copyTo(locator, draftCopy, strategy);
        if (draftCopy instanceof ClothoidType) {
            final ClothoidType copy = ((ClothoidType) draftCopy);
            if (this.isSetRefLocation()) {
                ClothoidType.RefLocation sourceRefLocation;
                sourceRefLocation = this.getRefLocation();
                ClothoidType.RefLocation copyRefLocation = ((ClothoidType.RefLocation) strategy.copy(LocatorUtils.property(locator, "refLocation", sourceRefLocation), sourceRefLocation));
                copy.setRefLocation(copyRefLocation);
            } else {
                copy.refLocation = null;
            }
            if (this.isSetScaleFactor()) {
                BigDecimal sourceScaleFactor;
                sourceScaleFactor = this.getScaleFactor();
                BigDecimal copyScaleFactor = ((BigDecimal) strategy.copy(LocatorUtils.property(locator, "scaleFactor", sourceScaleFactor), sourceScaleFactor));
                copy.setScaleFactor(copyScaleFactor);
            } else {
                copy.scaleFactor = null;
            }
            {
                double sourceStartParameter;
                sourceStartParameter = this.getStartParameter();
                double copyStartParameter = strategy.copy(LocatorUtils.property(locator, "startParameter", sourceStartParameter), sourceStartParameter);
                copy.setStartParameter(copyStartParameter);
            }
            {
                double sourceEndParameter;
                sourceEndParameter = this.getEndParameter();
                double copyEndParameter = strategy.copy(LocatorUtils.property(locator, "endParameter", sourceEndParameter), sourceEndParameter);
                copy.setEndParameter(copyEndParameter);
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new ClothoidType();
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element ref="{http://www.opengis.net/gml}AffinePlacement"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "affinePlacement"
    })
    public static class RefLocation
        implements Cloneable, CopyTo, Equals, HashCode, ToString
    {

        @XmlElement(name = "AffinePlacement", required = true)
        protected AffinePlacementType affinePlacement;

        /**
         * The "refLocation" is an affine mapping 
         *           that places  the curve defined by the Fresnel Integrals  
         *           into the co-ordinate reference system of this object.
         * 
         * @return
         *     possible object is
         *     {@link AffinePlacementType }
         *     
         */
        public AffinePlacementType getAffinePlacement() {
            return affinePlacement;
        }

        /**
         * Sets the value of the affinePlacement property.
         * 
         * @param value
         *     allowed object is
         *     {@link AffinePlacementType }
         *     
         */
        public void setAffinePlacement(AffinePlacementType value) {
            this.affinePlacement = value;
        }

        public boolean isSetAffinePlacement() {
            return (this.affinePlacement!= null);
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                AffinePlacementType theAffinePlacement;
                theAffinePlacement = this.getAffinePlacement();
                strategy.appendField(locator, this, "affinePlacement", buffer, theAffinePlacement);
            }
            return buffer;
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof ClothoidType.RefLocation)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final ClothoidType.RefLocation that = ((ClothoidType.RefLocation) object);
            {
                AffinePlacementType lhsAffinePlacement;
                lhsAffinePlacement = this.getAffinePlacement();
                AffinePlacementType rhsAffinePlacement;
                rhsAffinePlacement = that.getAffinePlacement();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "affinePlacement", lhsAffinePlacement), LocatorUtils.property(thatLocator, "affinePlacement", rhsAffinePlacement), lhsAffinePlacement, rhsAffinePlacement)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
            return equals(null, null, object, strategy);
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                AffinePlacementType theAffinePlacement;
                theAffinePlacement = this.getAffinePlacement();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "affinePlacement", theAffinePlacement), currentHashCode, theAffinePlacement);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public Object clone() {
            return copyTo(createNewInstance());
        }

        public Object copyTo(Object target) {
            final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
            return copyTo(null, target, strategy);
        }

        public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
            final Object draftCopy = ((target == null)?createNewInstance():target);
            if (draftCopy instanceof ClothoidType.RefLocation) {
                final ClothoidType.RefLocation copy = ((ClothoidType.RefLocation) draftCopy);
                if (this.isSetAffinePlacement()) {
                    AffinePlacementType sourceAffinePlacement;
                    sourceAffinePlacement = this.getAffinePlacement();
                    AffinePlacementType copyAffinePlacement = ((AffinePlacementType) strategy.copy(LocatorUtils.property(locator, "affinePlacement", sourceAffinePlacement), sourceAffinePlacement));
                    copy.setAffinePlacement(copyAffinePlacement);
                } else {
                    copy.affinePlacement = null;
                }
            }
            return draftCopy;
        }

        public Object createNewInstance() {
            return new ClothoidType.RefLocation();
        }

    }

}
